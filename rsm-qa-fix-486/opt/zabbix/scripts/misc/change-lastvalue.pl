#!/usr/bin/perl
#
# This script was created to fix gaps in SLV values somehow appeared after one of the upgrades. It attempts to go back
# and delete all data points generated by SLV scripts since specified DNS and RDDS clock (full cycle). This also affects
# "lastvalue" table, where "lastclock" would be set to the timestamp of the previous cycle, considering that it was the
# last one that had correct calculations.
#

use strict;
use warnings;

use Data::Dumper;

use lib '/opt/zabbix/scripts';

use RSM;
use RSMSLV;
use TLD_constants qw(:api :groups);

use constant EVENT_OBJECT_TRIGGER => 0;
use constant EVENT_SOURCE_TRIGGERS => 0;


sub __table($);
sub __get_tlds($$);
sub __delete_events($$);

parse_opts('dns-clock=n', 'rdds-clock=n', 'tld=s');

setopt('nolog');

my %clocks;

$clocks{'dns'} = getopt('dns-clock');
$clocks{'dnssec'} = getopt('dns-clock');
$clocks{'rdds'} = getopt('rdds-clock');

fail("usage: $0 --dns-clock <clock> --rdds-clock <clock>") unless ($clocks{'dns'} && $clocks{'rdds'});

my $config = get_rsm_config();

set_slv_config($config);

db_connect();

my %delays = (
	'dns' => get_dns_udp_delay($clocks{'dns'}),
	'dnssec' => get_dns_udp_delay($clocks{'dns'}),
	'rdds' => get_rdds_delay($clocks{'rdds'})
);

db_disconnect();

my %keys;

push(@{$keys{'dns'}},
	'rsm.slv.dns.avail',
	'rsm.slv.dns.downtime',
	'rsm.slv.dns.rollweek'
);

push(@{$keys{'dnssec'}},
	'rsm.slv.dnssec.avail',
	'rsm.slv.dnssec.rollweek'
);

push(@{$keys{'rdds'}},
	'rsm.slv.rdds.avail',
	'rsm.slv.rdds.downtime',
	'rsm.slv.rdds.rollweek'
);

$clocks{'dns'} = $clocks{'dns'} - ($clocks{'dns'} % $delays{'dns'});
$clocks{'dnssec'} = $clocks{'dnssec'} - ($clocks{'dnssec'} % $delays{'dnssec'});
$clocks{'rdds'} = $clocks{'rdds'} - ($clocks{'rdds'} % $delays{'rdds'});

info("DNS\t: ", scalar(localtime($clocks{'dns'})));
info("DNSSEC\t: ", scalar(localtime($clocks{'dnssec'})));
info("RDDS\t: ", scalar(localtime($clocks{'rdds'})));

my @server_keys = get_rsm_server_keys($config);

foreach (@server_keys)
{
	$server_key = $_;

	db_connect($server_key);

	tld_interface_enabled_delete_cache();   # delete cache of previous server_key
        tld_interface_enabled_create_cache($clocks{'dns'}, ('dns', 'dnssec', 'rdds43', 'rdds80', 'rdap'));

	foreach my $service (keys(%keys))
	{
		my $tlds = __get_tlds($service, $clocks{$service});

		next if (scalar(keys(%{$tlds})) == 0);

		foreach my $hostid (keys(%{$tlds}))
		{
			$tld = $tlds->{$hostid};

			my %itemids;

			foreach my $key (@{$keys{$service}})
			{
				my $rows_ref = db_select("select itemid,value_type from items where key_='$key' and hostid=$hostid");

				map {$itemids{$_->[0]} = $_->[1]} (@{$rows_ref});
			}

			my $clock_end = cycle_end($clocks{$service}, $delays{$service});

			foreach my $itemid (keys(%itemids))
			{
				my $rows_ref = db_select(
					"select clock,value".
					" from " . __table($itemids{$itemid}).
					" where itemid=$itemid".
						" and " . sql_time_condition($clocks{$service}, $clock_end)
				);

				if (opt('dry-run'))
				{
					if (scalar(@{$rows_ref}) == 0)
					{
						wrn("$service item ($itemid) does not have calculated cycle result at ", ts_full($clocks{$service}));
					}

					next;
				}

				if (scalar(@{$rows_ref}) == 0)
				{
					# set lastvalue
					db_exec("update lastvalue set clock=" . ($clocks{$service} - $delays{$service}) . " where itemid=$itemid");

					my $r = db_select("select key_ from items where itemid=$itemid");

					fail("$service item ($itemid) is missing calculated cycle result at ", ts_full($clocks{$service}),
						"\n\nrun: /opt/zabbix/scripts/slv/", $r->[0]->[0], ".pl --tld $tld --now ", $clocks{$service}, " --debug\n\nand run this script again");
				}

				if (scalar(@{$rows_ref}) != 1)
				{
					#fail("dimir was wrong, $service item ($itemid) can have duplicate cycle results: ", Dumper(@{$rows_ref}));
					my $row_ref = $rows_ref->[0];

					db_exec("delete from " . __table($itemids{$itemid}) . " where itemid=$itemid and " . sql_time_condition($clocks{$service}, $clock_end));

					db_exec("insert into " . __table($itemids{$itemid}) . " (`itemid`,`clock`,`value`) values ($itemid," . $clocks{$service} . "," . $row_ref->[1]. ")");
				}
				else
				{
					if ($rows_ref->[0]->[0] != $clocks{$service})
					{
						wrn("fixing $service history value of item $itemid...");

						db_exec("update ". __table($itemids{$itemid}) . " set itemid=$itemid,clock=" . $clocks{$service} . " where itemid=$itemid and clock=" . $rows_ref->[0]->[0]);
					}
				}

				# delete everything further
				db_exec("delete from " . __table($itemids{$itemid}) . " where itemid=$itemid and clock>" . $clocks{$service});

				# set lastvalue
				db_exec("update lastvalue set clock=" . $clocks{$service} . ",value=" . $rows_ref->[0]->[1]. " where itemid=$itemid");

				# delete events
				__delete_events($itemid, $clocks{$service});
			}
		}
	}

#	last if (opt('tld'));
}

sub __table($)
{
	my $value_type = shift;

	fail("THIS_SHOULD_NEVER_HAPPEN") unless (defined($value_type));

	return "history_uint" if ($value_type == ITEM_VALUE_TYPE_UINT64);
	return "history" if ($value_type == ITEM_VALUE_TYPE_FLOAT);

	fail("THIS_SHOULD_NEVER_HAPPEN");
}

sub __get_tlds($$)
{
	my $service = shift;
	my $now = shift;

	my $host_cond = "";

	$host_cond = " and h.host='" . getopt('tld') . "'" if (opt('tld'));

	my $rows_ref = db_select(
		"select distinct h.host,h.hostid".
		" from hosts h,hosts_groups hg".
		" where h.hostid=hg.hostid".
			" and hg.groupid=".TLDS_GROUPID.
			" and h.status=0".
			$host_cond.
		" order by h.host");

	my %tlds;
	foreach my $row_ref (@$rows_ref)
	{
		next unless (tld_service_enabled($row_ref->[0], $service, $now));

		$tlds{$row_ref->[1]} = $row_ref->[0];
	}

	return \%tlds;
}

sub __delete_events($$)
{
	my $itemid = shift;
	my $clock = shift;

	my $rows_ref = db_select(
		"select distinct t.triggerid".
		" from triggers t,functions f".
		" where t.triggerid=f.triggerid".
			" and f.itemid=$itemid"
	);

	foreach my $row_ref (@{$rows_ref})
	{
		my $triggerid = $row_ref->[0];

		db_exec(
			"delete from events".
			" where object=".EVENT_OBJECT_TRIGGER.
				" and source=".EVENT_SOURCE_TRIGGERS.
				" and objectid=$triggerid".
				" and clock>$clock"
		);
	}
}
